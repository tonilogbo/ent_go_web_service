// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"entrds/ent/album"
	"entrds/ent/artist"
	"entrds/ent/band"
	"entrds/ent/label"
	"entrds/ent/predicate"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum  = "Album"
	TypeArtist = "Artist"
	TypeBand   = "Band"
	TypeLabel  = "Label"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	release_year    *int
	addrelease_year *int
	clearedFields   map[string]struct{}
	band            map[int]struct{}
	removedband     map[int]struct{}
	clearedband     bool
	artist          map[int]struct{}
	removedartist   map[int]struct{}
	clearedartist   bool
	done            bool
	oldValue        func(context.Context) (*Album, error)
	predicates      []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id int) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlbumMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumMutation) ResetName() {
	m.name = nil
}

// SetReleaseYear sets the "release_year" field.
func (m *AlbumMutation) SetReleaseYear(i int) {
	m.release_year = &i
	m.addrelease_year = nil
}

// ReleaseYear returns the value of the "release_year" field in the mutation.
func (m *AlbumMutation) ReleaseYear() (r int, exists bool) {
	v := m.release_year
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseYear returns the old "release_year" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldReleaseYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseYear: %w", err)
	}
	return oldValue.ReleaseYear, nil
}

// AddReleaseYear adds i to the "release_year" field.
func (m *AlbumMutation) AddReleaseYear(i int) {
	if m.addrelease_year != nil {
		*m.addrelease_year += i
	} else {
		m.addrelease_year = &i
	}
}

// AddedReleaseYear returns the value that was added to the "release_year" field in this mutation.
func (m *AlbumMutation) AddedReleaseYear() (r int, exists bool) {
	v := m.addrelease_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetReleaseYear resets all changes to the "release_year" field.
func (m *AlbumMutation) ResetReleaseYear() {
	m.release_year = nil
	m.addrelease_year = nil
}

// AddBandIDs adds the "band" edge to the Band entity by ids.
func (m *AlbumMutation) AddBandIDs(ids ...int) {
	if m.band == nil {
		m.band = make(map[int]struct{})
	}
	for i := range ids {
		m.band[ids[i]] = struct{}{}
	}
}

// ClearBand clears the "band" edge to the Band entity.
func (m *AlbumMutation) ClearBand() {
	m.clearedband = true
}

// BandCleared reports if the "band" edge to the Band entity was cleared.
func (m *AlbumMutation) BandCleared() bool {
	return m.clearedband
}

// RemoveBandIDs removes the "band" edge to the Band entity by IDs.
func (m *AlbumMutation) RemoveBandIDs(ids ...int) {
	if m.removedband == nil {
		m.removedband = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.band, ids[i])
		m.removedband[ids[i]] = struct{}{}
	}
}

// RemovedBand returns the removed IDs of the "band" edge to the Band entity.
func (m *AlbumMutation) RemovedBandIDs() (ids []int) {
	for id := range m.removedband {
		ids = append(ids, id)
	}
	return
}

// BandIDs returns the "band" edge IDs in the mutation.
func (m *AlbumMutation) BandIDs() (ids []int) {
	for id := range m.band {
		ids = append(ids, id)
	}
	return
}

// ResetBand resets all changes to the "band" edge.
func (m *AlbumMutation) ResetBand() {
	m.band = nil
	m.clearedband = false
	m.removedband = nil
}

// AddArtistIDs adds the "artist" edge to the Artist entity by ids.
func (m *AlbumMutation) AddArtistIDs(ids ...int) {
	if m.artist == nil {
		m.artist = make(map[int]struct{})
	}
	for i := range ids {
		m.artist[ids[i]] = struct{}{}
	}
}

// ClearArtist clears the "artist" edge to the Artist entity.
func (m *AlbumMutation) ClearArtist() {
	m.clearedartist = true
}

// ArtistCleared reports if the "artist" edge to the Artist entity was cleared.
func (m *AlbumMutation) ArtistCleared() bool {
	return m.clearedartist
}

// RemoveArtistIDs removes the "artist" edge to the Artist entity by IDs.
func (m *AlbumMutation) RemoveArtistIDs(ids ...int) {
	if m.removedartist == nil {
		m.removedartist = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artist, ids[i])
		m.removedartist[ids[i]] = struct{}{}
	}
}

// RemovedArtist returns the removed IDs of the "artist" edge to the Artist entity.
func (m *AlbumMutation) RemovedArtistIDs() (ids []int) {
	for id := range m.removedartist {
		ids = append(ids, id)
	}
	return
}

// ArtistIDs returns the "artist" edge IDs in the mutation.
func (m *AlbumMutation) ArtistIDs() (ids []int) {
	for id := range m.artist {
		ids = append(ids, id)
	}
	return
}

// ResetArtist resets all changes to the "artist" edge.
func (m *AlbumMutation) ResetArtist() {
	m.artist = nil
	m.clearedartist = false
	m.removedartist = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, album.FieldName)
	}
	if m.release_year != nil {
		fields = append(fields, album.FieldReleaseYear)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldName:
		return m.Name()
	case album.FieldReleaseYear:
		return m.ReleaseYear()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldName:
		return m.OldName(ctx)
	case album.FieldReleaseYear:
		return m.OldReleaseYear(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case album.FieldReleaseYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseYear(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	var fields []string
	if m.addrelease_year != nil {
		fields = append(fields, album.FieldReleaseYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case album.FieldReleaseYear:
		return m.AddedReleaseYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case album.FieldReleaseYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReleaseYear(v)
		return nil
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldName:
		m.ResetName()
		return nil
	case album.FieldReleaseYear:
		m.ResetReleaseYear()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.band != nil {
		edges = append(edges, album.EdgeBand)
	}
	if m.artist != nil {
		edges = append(edges, album.EdgeArtist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeBand:
		ids := make([]ent.Value, 0, len(m.band))
		for id := range m.band {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeArtist:
		ids := make([]ent.Value, 0, len(m.artist))
		for id := range m.artist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedband != nil {
		edges = append(edges, album.EdgeBand)
	}
	if m.removedartist != nil {
		edges = append(edges, album.EdgeArtist)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeBand:
		ids := make([]ent.Value, 0, len(m.removedband))
		for id := range m.removedband {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeArtist:
		ids := make([]ent.Value, 0, len(m.removedartist))
		for id := range m.removedartist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedband {
		edges = append(edges, album.EdgeBand)
	}
	if m.clearedartist {
		edges = append(edges, album.EdgeArtist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	switch name {
	case album.EdgeBand:
		return m.clearedband
	case album.EdgeArtist:
		return m.clearedartist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	switch name {
	case album.EdgeBand:
		m.ResetBand()
		return nil
	case album.EdgeArtist:
		m.ResetArtist()
		return nil
	}
	return fmt.Errorf("unknown Album edge %s", name)
}

// ArtistMutation represents an operation that mutates the Artist nodes in the graph.
type ArtistMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	date_of_birth             *time.Time
	gender                    *string
	clearedFields             map[string]struct{}
	bands                     map[int]struct{}
	removedbands              map[int]struct{}
	clearedbands              bool
	albums                    map[int]struct{}
	removedalbums             map[int]struct{}
	clearedalbums             bool
	associated_artists        map[int]struct{}
	removedassociated_artists map[int]struct{}
	clearedassociated_artists bool
	label                     map[int]struct{}
	removedlabel              map[int]struct{}
	clearedlabel              bool
	done                      bool
	oldValue                  func(context.Context) (*Artist, error)
	predicates                []predicate.Artist
}

var _ ent.Mutation = (*ArtistMutation)(nil)

// artistOption allows management of the mutation configuration using functional options.
type artistOption func(*ArtistMutation)

// newArtistMutation creates new mutation for the Artist entity.
func newArtistMutation(c config, op Op, opts ...artistOption) *ArtistMutation {
	m := &ArtistMutation{
		config:        c,
		op:            op,
		typ:           TypeArtist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtistID sets the ID field of the mutation.
func withArtistID(id int) artistOption {
	return func(m *ArtistMutation) {
		var (
			err   error
			once  sync.Once
			value *Artist
		)
		m.oldValue = func(ctx context.Context) (*Artist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtist sets the old Artist of the mutation.
func withArtist(node *Artist) artistOption {
	return func(m *ArtistMutation) {
		m.oldValue = func(context.Context) (*Artist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ArtistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtistMutation) ResetName() {
	m.name = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *ArtistMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *ArtistMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *ArtistMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[artist.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *ArtistMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[artist.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *ArtistMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, artist.FieldDateOfBirth)
}

// SetGender sets the "gender" field.
func (m *ArtistMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ArtistMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *ArtistMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[artist.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *ArtistMutation) GenderCleared() bool {
	_, ok := m.clearedFields[artist.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *ArtistMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, artist.FieldGender)
}

// AddBandIDs adds the "bands" edge to the Band entity by ids.
func (m *ArtistMutation) AddBandIDs(ids ...int) {
	if m.bands == nil {
		m.bands = make(map[int]struct{})
	}
	for i := range ids {
		m.bands[ids[i]] = struct{}{}
	}
}

// ClearBands clears the "bands" edge to the Band entity.
func (m *ArtistMutation) ClearBands() {
	m.clearedbands = true
}

// BandsCleared reports if the "bands" edge to the Band entity was cleared.
func (m *ArtistMutation) BandsCleared() bool {
	return m.clearedbands
}

// RemoveBandIDs removes the "bands" edge to the Band entity by IDs.
func (m *ArtistMutation) RemoveBandIDs(ids ...int) {
	if m.removedbands == nil {
		m.removedbands = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bands, ids[i])
		m.removedbands[ids[i]] = struct{}{}
	}
}

// RemovedBands returns the removed IDs of the "bands" edge to the Band entity.
func (m *ArtistMutation) RemovedBandsIDs() (ids []int) {
	for id := range m.removedbands {
		ids = append(ids, id)
	}
	return
}

// BandsIDs returns the "bands" edge IDs in the mutation.
func (m *ArtistMutation) BandsIDs() (ids []int) {
	for id := range m.bands {
		ids = append(ids, id)
	}
	return
}

// ResetBands resets all changes to the "bands" edge.
func (m *ArtistMutation) ResetBands() {
	m.bands = nil
	m.clearedbands = false
	m.removedbands = nil
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *ArtistMutation) AddAlbumIDs(ids ...int) {
	if m.albums == nil {
		m.albums = make(map[int]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *ArtistMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *ArtistMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *ArtistMutation) RemoveAlbumIDs(ids ...int) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *ArtistMutation) RemovedAlbumsIDs() (ids []int) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *ArtistMutation) AlbumsIDs() (ids []int) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *ArtistMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// AddAssociatedArtistIDs adds the "associated_artists" edge to the Artist entity by ids.
func (m *ArtistMutation) AddAssociatedArtistIDs(ids ...int) {
	if m.associated_artists == nil {
		m.associated_artists = make(map[int]struct{})
	}
	for i := range ids {
		m.associated_artists[ids[i]] = struct{}{}
	}
}

// ClearAssociatedArtists clears the "associated_artists" edge to the Artist entity.
func (m *ArtistMutation) ClearAssociatedArtists() {
	m.clearedassociated_artists = true
}

// AssociatedArtistsCleared reports if the "associated_artists" edge to the Artist entity was cleared.
func (m *ArtistMutation) AssociatedArtistsCleared() bool {
	return m.clearedassociated_artists
}

// RemoveAssociatedArtistIDs removes the "associated_artists" edge to the Artist entity by IDs.
func (m *ArtistMutation) RemoveAssociatedArtistIDs(ids ...int) {
	if m.removedassociated_artists == nil {
		m.removedassociated_artists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.associated_artists, ids[i])
		m.removedassociated_artists[ids[i]] = struct{}{}
	}
}

// RemovedAssociatedArtists returns the removed IDs of the "associated_artists" edge to the Artist entity.
func (m *ArtistMutation) RemovedAssociatedArtistsIDs() (ids []int) {
	for id := range m.removedassociated_artists {
		ids = append(ids, id)
	}
	return
}

// AssociatedArtistsIDs returns the "associated_artists" edge IDs in the mutation.
func (m *ArtistMutation) AssociatedArtistsIDs() (ids []int) {
	for id := range m.associated_artists {
		ids = append(ids, id)
	}
	return
}

// ResetAssociatedArtists resets all changes to the "associated_artists" edge.
func (m *ArtistMutation) ResetAssociatedArtists() {
	m.associated_artists = nil
	m.clearedassociated_artists = false
	m.removedassociated_artists = nil
}

// AddLabelIDs adds the "label" edge to the Label entity by ids.
func (m *ArtistMutation) AddLabelIDs(ids ...int) {
	if m.label == nil {
		m.label = make(map[int]struct{})
	}
	for i := range ids {
		m.label[ids[i]] = struct{}{}
	}
}

// ClearLabel clears the "label" edge to the Label entity.
func (m *ArtistMutation) ClearLabel() {
	m.clearedlabel = true
}

// LabelCleared reports if the "label" edge to the Label entity was cleared.
func (m *ArtistMutation) LabelCleared() bool {
	return m.clearedlabel
}

// RemoveLabelIDs removes the "label" edge to the Label entity by IDs.
func (m *ArtistMutation) RemoveLabelIDs(ids ...int) {
	if m.removedlabel == nil {
		m.removedlabel = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.label, ids[i])
		m.removedlabel[ids[i]] = struct{}{}
	}
}

// RemovedLabel returns the removed IDs of the "label" edge to the Label entity.
func (m *ArtistMutation) RemovedLabelIDs() (ids []int) {
	for id := range m.removedlabel {
		ids = append(ids, id)
	}
	return
}

// LabelIDs returns the "label" edge IDs in the mutation.
func (m *ArtistMutation) LabelIDs() (ids []int) {
	for id := range m.label {
		ids = append(ids, id)
	}
	return
}

// ResetLabel resets all changes to the "label" edge.
func (m *ArtistMutation) ResetLabel() {
	m.label = nil
	m.clearedlabel = false
	m.removedlabel = nil
}

// Where appends a list predicates to the ArtistMutation builder.
func (m *ArtistMutation) Where(ps ...predicate.Artist) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArtistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artist).
func (m *ArtistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtistMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, artist.FieldName)
	}
	if m.date_of_birth != nil {
		fields = append(fields, artist.FieldDateOfBirth)
	}
	if m.gender != nil {
		fields = append(fields, artist.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artist.FieldName:
		return m.Name()
	case artist.FieldDateOfBirth:
		return m.DateOfBirth()
	case artist.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artist.FieldName:
		return m.OldName(ctx)
	case artist.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case artist.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Artist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artist.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case artist.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artist.FieldDateOfBirth) {
		fields = append(fields, artist.FieldDateOfBirth)
	}
	if m.FieldCleared(artist.FieldGender) {
		fields = append(fields, artist.FieldGender)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtistMutation) ClearField(name string) error {
	switch name {
	case artist.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case artist.FieldGender:
		m.ClearGender()
		return nil
	}
	return fmt.Errorf("unknown Artist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtistMutation) ResetField(name string) error {
	switch name {
	case artist.FieldName:
		m.ResetName()
		return nil
	case artist.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case artist.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtistMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.bands != nil {
		edges = append(edges, artist.EdgeBands)
	}
	if m.albums != nil {
		edges = append(edges, artist.EdgeAlbums)
	}
	if m.associated_artists != nil {
		edges = append(edges, artist.EdgeAssociatedArtists)
	}
	if m.label != nil {
		edges = append(edges, artist.EdgeLabel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeBands:
		ids := make([]ent.Value, 0, len(m.bands))
		for id := range m.bands {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeAssociatedArtists:
		ids := make([]ent.Value, 0, len(m.associated_artists))
		for id := range m.associated_artists {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.label))
		for id := range m.label {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbands != nil {
		edges = append(edges, artist.EdgeBands)
	}
	if m.removedalbums != nil {
		edges = append(edges, artist.EdgeAlbums)
	}
	if m.removedassociated_artists != nil {
		edges = append(edges, artist.EdgeAssociatedArtists)
	}
	if m.removedlabel != nil {
		edges = append(edges, artist.EdgeLabel)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeBands:
		ids := make([]ent.Value, 0, len(m.removedbands))
		for id := range m.removedbands {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeAssociatedArtists:
		ids := make([]ent.Value, 0, len(m.removedassociated_artists))
		for id := range m.removedassociated_artists {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.removedlabel))
		for id := range m.removedlabel {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbands {
		edges = append(edges, artist.EdgeBands)
	}
	if m.clearedalbums {
		edges = append(edges, artist.EdgeAlbums)
	}
	if m.clearedassociated_artists {
		edges = append(edges, artist.EdgeAssociatedArtists)
	}
	if m.clearedlabel {
		edges = append(edges, artist.EdgeLabel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtistMutation) EdgeCleared(name string) bool {
	switch name {
	case artist.EdgeBands:
		return m.clearedbands
	case artist.EdgeAlbums:
		return m.clearedalbums
	case artist.EdgeAssociatedArtists:
		return m.clearedassociated_artists
	case artist.EdgeLabel:
		return m.clearedlabel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtistMutation) ResetEdge(name string) error {
	switch name {
	case artist.EdgeBands:
		m.ResetBands()
		return nil
	case artist.EdgeAlbums:
		m.ResetAlbums()
		return nil
	case artist.EdgeAssociatedArtists:
		m.ResetAssociatedArtists()
		return nil
	case artist.EdgeLabel:
		m.ResetLabel()
		return nil
	}
	return fmt.Errorf("unknown Artist edge %s", name)
}

// BandMutation represents an operation that mutates the Band nodes in the graph.
type BandMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	year_formed             *int
	addyear_formed          *int
	clearedFields           map[string]struct{}
	members                 map[int]struct{}
	removedmembers          map[int]struct{}
	clearedmembers          bool
	albums                  map[int]struct{}
	removedalbums           map[int]struct{}
	clearedalbums           bool
	associated_bands        map[int]struct{}
	removedassociated_bands map[int]struct{}
	clearedassociated_bands bool
	label                   map[int]struct{}
	removedlabel            map[int]struct{}
	clearedlabel            bool
	done                    bool
	oldValue                func(context.Context) (*Band, error)
	predicates              []predicate.Band
}

var _ ent.Mutation = (*BandMutation)(nil)

// bandOption allows management of the mutation configuration using functional options.
type bandOption func(*BandMutation)

// newBandMutation creates new mutation for the Band entity.
func newBandMutation(c config, op Op, opts ...bandOption) *BandMutation {
	m := &BandMutation{
		config:        c,
		op:            op,
		typ:           TypeBand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBandID sets the ID field of the mutation.
func withBandID(id int) bandOption {
	return func(m *BandMutation) {
		var (
			err   error
			once  sync.Once
			value *Band
		)
		m.oldValue = func(ctx context.Context) (*Band, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Band.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBand sets the old Band of the mutation.
func withBand(node *Band) bandOption {
	return func(m *BandMutation) {
		m.oldValue = func(context.Context) (*Band, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BandMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Band.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Band entity.
// If the Band object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BandMutation) ResetName() {
	m.name = nil
}

// SetYearFormed sets the "year_formed" field.
func (m *BandMutation) SetYearFormed(i int) {
	m.year_formed = &i
	m.addyear_formed = nil
}

// YearFormed returns the value of the "year_formed" field in the mutation.
func (m *BandMutation) YearFormed() (r int, exists bool) {
	v := m.year_formed
	if v == nil {
		return
	}
	return *v, true
}

// OldYearFormed returns the old "year_formed" field's value of the Band entity.
// If the Band object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BandMutation) OldYearFormed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearFormed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearFormed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearFormed: %w", err)
	}
	return oldValue.YearFormed, nil
}

// AddYearFormed adds i to the "year_formed" field.
func (m *BandMutation) AddYearFormed(i int) {
	if m.addyear_formed != nil {
		*m.addyear_formed += i
	} else {
		m.addyear_formed = &i
	}
}

// AddedYearFormed returns the value that was added to the "year_formed" field in this mutation.
func (m *BandMutation) AddedYearFormed() (r int, exists bool) {
	v := m.addyear_formed
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearFormed clears the value of the "year_formed" field.
func (m *BandMutation) ClearYearFormed() {
	m.year_formed = nil
	m.addyear_formed = nil
	m.clearedFields[band.FieldYearFormed] = struct{}{}
}

// YearFormedCleared returns if the "year_formed" field was cleared in this mutation.
func (m *BandMutation) YearFormedCleared() bool {
	_, ok := m.clearedFields[band.FieldYearFormed]
	return ok
}

// ResetYearFormed resets all changes to the "year_formed" field.
func (m *BandMutation) ResetYearFormed() {
	m.year_formed = nil
	m.addyear_formed = nil
	delete(m.clearedFields, band.FieldYearFormed)
}

// AddMemberIDs adds the "members" edge to the Artist entity by ids.
func (m *BandMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Artist entity.
func (m *BandMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Artist entity was cleared.
func (m *BandMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Artist entity by IDs.
func (m *BandMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Artist entity.
func (m *BandMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *BandMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *BandMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *BandMutation) AddAlbumIDs(ids ...int) {
	if m.albums == nil {
		m.albums = make(map[int]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *BandMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *BandMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *BandMutation) RemoveAlbumIDs(ids ...int) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *BandMutation) RemovedAlbumsIDs() (ids []int) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *BandMutation) AlbumsIDs() (ids []int) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *BandMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// AddAssociatedBandIDs adds the "associated_bands" edge to the Band entity by ids.
func (m *BandMutation) AddAssociatedBandIDs(ids ...int) {
	if m.associated_bands == nil {
		m.associated_bands = make(map[int]struct{})
	}
	for i := range ids {
		m.associated_bands[ids[i]] = struct{}{}
	}
}

// ClearAssociatedBands clears the "associated_bands" edge to the Band entity.
func (m *BandMutation) ClearAssociatedBands() {
	m.clearedassociated_bands = true
}

// AssociatedBandsCleared reports if the "associated_bands" edge to the Band entity was cleared.
func (m *BandMutation) AssociatedBandsCleared() bool {
	return m.clearedassociated_bands
}

// RemoveAssociatedBandIDs removes the "associated_bands" edge to the Band entity by IDs.
func (m *BandMutation) RemoveAssociatedBandIDs(ids ...int) {
	if m.removedassociated_bands == nil {
		m.removedassociated_bands = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.associated_bands, ids[i])
		m.removedassociated_bands[ids[i]] = struct{}{}
	}
}

// RemovedAssociatedBands returns the removed IDs of the "associated_bands" edge to the Band entity.
func (m *BandMutation) RemovedAssociatedBandsIDs() (ids []int) {
	for id := range m.removedassociated_bands {
		ids = append(ids, id)
	}
	return
}

// AssociatedBandsIDs returns the "associated_bands" edge IDs in the mutation.
func (m *BandMutation) AssociatedBandsIDs() (ids []int) {
	for id := range m.associated_bands {
		ids = append(ids, id)
	}
	return
}

// ResetAssociatedBands resets all changes to the "associated_bands" edge.
func (m *BandMutation) ResetAssociatedBands() {
	m.associated_bands = nil
	m.clearedassociated_bands = false
	m.removedassociated_bands = nil
}

// AddLabelIDs adds the "label" edge to the Label entity by ids.
func (m *BandMutation) AddLabelIDs(ids ...int) {
	if m.label == nil {
		m.label = make(map[int]struct{})
	}
	for i := range ids {
		m.label[ids[i]] = struct{}{}
	}
}

// ClearLabel clears the "label" edge to the Label entity.
func (m *BandMutation) ClearLabel() {
	m.clearedlabel = true
}

// LabelCleared reports if the "label" edge to the Label entity was cleared.
func (m *BandMutation) LabelCleared() bool {
	return m.clearedlabel
}

// RemoveLabelIDs removes the "label" edge to the Label entity by IDs.
func (m *BandMutation) RemoveLabelIDs(ids ...int) {
	if m.removedlabel == nil {
		m.removedlabel = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.label, ids[i])
		m.removedlabel[ids[i]] = struct{}{}
	}
}

// RemovedLabel returns the removed IDs of the "label" edge to the Label entity.
func (m *BandMutation) RemovedLabelIDs() (ids []int) {
	for id := range m.removedlabel {
		ids = append(ids, id)
	}
	return
}

// LabelIDs returns the "label" edge IDs in the mutation.
func (m *BandMutation) LabelIDs() (ids []int) {
	for id := range m.label {
		ids = append(ids, id)
	}
	return
}

// ResetLabel resets all changes to the "label" edge.
func (m *BandMutation) ResetLabel() {
	m.label = nil
	m.clearedlabel = false
	m.removedlabel = nil
}

// Where appends a list predicates to the BandMutation builder.
func (m *BandMutation) Where(ps ...predicate.Band) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Band).
func (m *BandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BandMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, band.FieldName)
	}
	if m.year_formed != nil {
		fields = append(fields, band.FieldYearFormed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case band.FieldName:
		return m.Name()
	case band.FieldYearFormed:
		return m.YearFormed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case band.FieldName:
		return m.OldName(ctx)
	case band.FieldYearFormed:
		return m.OldYearFormed(ctx)
	}
	return nil, fmt.Errorf("unknown Band field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case band.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case band.FieldYearFormed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearFormed(v)
		return nil
	}
	return fmt.Errorf("unknown Band field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BandMutation) AddedFields() []string {
	var fields []string
	if m.addyear_formed != nil {
		fields = append(fields, band.FieldYearFormed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case band.FieldYearFormed:
		return m.AddedYearFormed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case band.FieldYearFormed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearFormed(v)
		return nil
	}
	return fmt.Errorf("unknown Band numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(band.FieldYearFormed) {
		fields = append(fields, band.FieldYearFormed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BandMutation) ClearField(name string) error {
	switch name {
	case band.FieldYearFormed:
		m.ClearYearFormed()
		return nil
	}
	return fmt.Errorf("unknown Band nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BandMutation) ResetField(name string) error {
	switch name {
	case band.FieldName:
		m.ResetName()
		return nil
	case band.FieldYearFormed:
		m.ResetYearFormed()
		return nil
	}
	return fmt.Errorf("unknown Band field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BandMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.members != nil {
		edges = append(edges, band.EdgeMembers)
	}
	if m.albums != nil {
		edges = append(edges, band.EdgeAlbums)
	}
	if m.associated_bands != nil {
		edges = append(edges, band.EdgeAssociatedBands)
	}
	if m.label != nil {
		edges = append(edges, band.EdgeLabel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case band.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case band.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	case band.EdgeAssociatedBands:
		ids := make([]ent.Value, 0, len(m.associated_bands))
		for id := range m.associated_bands {
			ids = append(ids, id)
		}
		return ids
	case band.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.label))
		for id := range m.label {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, band.EdgeMembers)
	}
	if m.removedalbums != nil {
		edges = append(edges, band.EdgeAlbums)
	}
	if m.removedassociated_bands != nil {
		edges = append(edges, band.EdgeAssociatedBands)
	}
	if m.removedlabel != nil {
		edges = append(edges, band.EdgeLabel)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case band.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case band.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	case band.EdgeAssociatedBands:
		ids := make([]ent.Value, 0, len(m.removedassociated_bands))
		for id := range m.removedassociated_bands {
			ids = append(ids, id)
		}
		return ids
	case band.EdgeLabel:
		ids := make([]ent.Value, 0, len(m.removedlabel))
		for id := range m.removedlabel {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmembers {
		edges = append(edges, band.EdgeMembers)
	}
	if m.clearedalbums {
		edges = append(edges, band.EdgeAlbums)
	}
	if m.clearedassociated_bands {
		edges = append(edges, band.EdgeAssociatedBands)
	}
	if m.clearedlabel {
		edges = append(edges, band.EdgeLabel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BandMutation) EdgeCleared(name string) bool {
	switch name {
	case band.EdgeMembers:
		return m.clearedmembers
	case band.EdgeAlbums:
		return m.clearedalbums
	case band.EdgeAssociatedBands:
		return m.clearedassociated_bands
	case band.EdgeLabel:
		return m.clearedlabel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Band unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BandMutation) ResetEdge(name string) error {
	switch name {
	case band.EdgeMembers:
		m.ResetMembers()
		return nil
	case band.EdgeAlbums:
		m.ResetAlbums()
		return nil
	case band.EdgeAssociatedBands:
		m.ResetAssociatedBands()
		return nil
	case band.EdgeLabel:
		m.ResetLabel()
		return nil
	}
	return fmt.Errorf("unknown Band edge %s", name)
}

// LabelMutation represents an operation that mutates the Label nodes in the graph.
type LabelMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	year_established          *int
	addyear_established       *int
	clearedFields             map[string]struct{}
	individual_artists        map[int]struct{}
	removedindividual_artists map[int]struct{}
	clearedindividual_artists bool
	bands                     map[int]struct{}
	removedbands              map[int]struct{}
	clearedbands              bool
	done                      bool
	oldValue                  func(context.Context) (*Label, error)
	predicates                []predicate.Label
}

var _ ent.Mutation = (*LabelMutation)(nil)

// labelOption allows management of the mutation configuration using functional options.
type labelOption func(*LabelMutation)

// newLabelMutation creates new mutation for the Label entity.
func newLabelMutation(c config, op Op, opts ...labelOption) *LabelMutation {
	m := &LabelMutation{
		config:        c,
		op:            op,
		typ:           TypeLabel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLabelID sets the ID field of the mutation.
func withLabelID(id int) labelOption {
	return func(m *LabelMutation) {
		var (
			err   error
			once  sync.Once
			value *Label
		)
		m.oldValue = func(ctx context.Context) (*Label, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Label.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLabel sets the old Label of the mutation.
func withLabel(node *Label) labelOption {
	return func(m *LabelMutation) {
		m.oldValue = func(context.Context) (*Label, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Label.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LabelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LabelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LabelMutation) ResetName() {
	m.name = nil
}

// SetYearEstablished sets the "year_established" field.
func (m *LabelMutation) SetYearEstablished(i int) {
	m.year_established = &i
	m.addyear_established = nil
}

// YearEstablished returns the value of the "year_established" field in the mutation.
func (m *LabelMutation) YearEstablished() (r int, exists bool) {
	v := m.year_established
	if v == nil {
		return
	}
	return *v, true
}

// OldYearEstablished returns the old "year_established" field's value of the Label entity.
// If the Label object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabelMutation) OldYearEstablished(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearEstablished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearEstablished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearEstablished: %w", err)
	}
	return oldValue.YearEstablished, nil
}

// AddYearEstablished adds i to the "year_established" field.
func (m *LabelMutation) AddYearEstablished(i int) {
	if m.addyear_established != nil {
		*m.addyear_established += i
	} else {
		m.addyear_established = &i
	}
}

// AddedYearEstablished returns the value that was added to the "year_established" field in this mutation.
func (m *LabelMutation) AddedYearEstablished() (r int, exists bool) {
	v := m.addyear_established
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearEstablished clears the value of the "year_established" field.
func (m *LabelMutation) ClearYearEstablished() {
	m.year_established = nil
	m.addyear_established = nil
	m.clearedFields[label.FieldYearEstablished] = struct{}{}
}

// YearEstablishedCleared returns if the "year_established" field was cleared in this mutation.
func (m *LabelMutation) YearEstablishedCleared() bool {
	_, ok := m.clearedFields[label.FieldYearEstablished]
	return ok
}

// ResetYearEstablished resets all changes to the "year_established" field.
func (m *LabelMutation) ResetYearEstablished() {
	m.year_established = nil
	m.addyear_established = nil
	delete(m.clearedFields, label.FieldYearEstablished)
}

// AddIndividualArtistIDs adds the "individual_artists" edge to the Artist entity by ids.
func (m *LabelMutation) AddIndividualArtistIDs(ids ...int) {
	if m.individual_artists == nil {
		m.individual_artists = make(map[int]struct{})
	}
	for i := range ids {
		m.individual_artists[ids[i]] = struct{}{}
	}
}

// ClearIndividualArtists clears the "individual_artists" edge to the Artist entity.
func (m *LabelMutation) ClearIndividualArtists() {
	m.clearedindividual_artists = true
}

// IndividualArtistsCleared reports if the "individual_artists" edge to the Artist entity was cleared.
func (m *LabelMutation) IndividualArtistsCleared() bool {
	return m.clearedindividual_artists
}

// RemoveIndividualArtistIDs removes the "individual_artists" edge to the Artist entity by IDs.
func (m *LabelMutation) RemoveIndividualArtistIDs(ids ...int) {
	if m.removedindividual_artists == nil {
		m.removedindividual_artists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.individual_artists, ids[i])
		m.removedindividual_artists[ids[i]] = struct{}{}
	}
}

// RemovedIndividualArtists returns the removed IDs of the "individual_artists" edge to the Artist entity.
func (m *LabelMutation) RemovedIndividualArtistsIDs() (ids []int) {
	for id := range m.removedindividual_artists {
		ids = append(ids, id)
	}
	return
}

// IndividualArtistsIDs returns the "individual_artists" edge IDs in the mutation.
func (m *LabelMutation) IndividualArtistsIDs() (ids []int) {
	for id := range m.individual_artists {
		ids = append(ids, id)
	}
	return
}

// ResetIndividualArtists resets all changes to the "individual_artists" edge.
func (m *LabelMutation) ResetIndividualArtists() {
	m.individual_artists = nil
	m.clearedindividual_artists = false
	m.removedindividual_artists = nil
}

// AddBandIDs adds the "bands" edge to the Band entity by ids.
func (m *LabelMutation) AddBandIDs(ids ...int) {
	if m.bands == nil {
		m.bands = make(map[int]struct{})
	}
	for i := range ids {
		m.bands[ids[i]] = struct{}{}
	}
}

// ClearBands clears the "bands" edge to the Band entity.
func (m *LabelMutation) ClearBands() {
	m.clearedbands = true
}

// BandsCleared reports if the "bands" edge to the Band entity was cleared.
func (m *LabelMutation) BandsCleared() bool {
	return m.clearedbands
}

// RemoveBandIDs removes the "bands" edge to the Band entity by IDs.
func (m *LabelMutation) RemoveBandIDs(ids ...int) {
	if m.removedbands == nil {
		m.removedbands = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bands, ids[i])
		m.removedbands[ids[i]] = struct{}{}
	}
}

// RemovedBands returns the removed IDs of the "bands" edge to the Band entity.
func (m *LabelMutation) RemovedBandsIDs() (ids []int) {
	for id := range m.removedbands {
		ids = append(ids, id)
	}
	return
}

// BandsIDs returns the "bands" edge IDs in the mutation.
func (m *LabelMutation) BandsIDs() (ids []int) {
	for id := range m.bands {
		ids = append(ids, id)
	}
	return
}

// ResetBands resets all changes to the "bands" edge.
func (m *LabelMutation) ResetBands() {
	m.bands = nil
	m.clearedbands = false
	m.removedbands = nil
}

// Where appends a list predicates to the LabelMutation builder.
func (m *LabelMutation) Where(ps ...predicate.Label) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LabelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Label).
func (m *LabelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabelMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, label.FieldName)
	}
	if m.year_established != nil {
		fields = append(fields, label.FieldYearEstablished)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case label.FieldName:
		return m.Name()
	case label.FieldYearEstablished:
		return m.YearEstablished()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case label.FieldName:
		return m.OldName(ctx)
	case label.FieldYearEstablished:
		return m.OldYearEstablished(ctx)
	}
	return nil, fmt.Errorf("unknown Label field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case label.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case label.FieldYearEstablished:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearEstablished(v)
		return nil
	}
	return fmt.Errorf("unknown Label field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabelMutation) AddedFields() []string {
	var fields []string
	if m.addyear_established != nil {
		fields = append(fields, label.FieldYearEstablished)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case label.FieldYearEstablished:
		return m.AddedYearEstablished()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case label.FieldYearEstablished:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearEstablished(v)
		return nil
	}
	return fmt.Errorf("unknown Label numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(label.FieldYearEstablished) {
		fields = append(fields, label.FieldYearEstablished)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabelMutation) ClearField(name string) error {
	switch name {
	case label.FieldYearEstablished:
		m.ClearYearEstablished()
		return nil
	}
	return fmt.Errorf("unknown Label nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabelMutation) ResetField(name string) error {
	switch name {
	case label.FieldName:
		m.ResetName()
		return nil
	case label.FieldYearEstablished:
		m.ResetYearEstablished()
		return nil
	}
	return fmt.Errorf("unknown Label field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.individual_artists != nil {
		edges = append(edges, label.EdgeIndividualArtists)
	}
	if m.bands != nil {
		edges = append(edges, label.EdgeBands)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case label.EdgeIndividualArtists:
		ids := make([]ent.Value, 0, len(m.individual_artists))
		for id := range m.individual_artists {
			ids = append(ids, id)
		}
		return ids
	case label.EdgeBands:
		ids := make([]ent.Value, 0, len(m.bands))
		for id := range m.bands {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedindividual_artists != nil {
		edges = append(edges, label.EdgeIndividualArtists)
	}
	if m.removedbands != nil {
		edges = append(edges, label.EdgeBands)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case label.EdgeIndividualArtists:
		ids := make([]ent.Value, 0, len(m.removedindividual_artists))
		for id := range m.removedindividual_artists {
			ids = append(ids, id)
		}
		return ids
	case label.EdgeBands:
		ids := make([]ent.Value, 0, len(m.removedbands))
		for id := range m.removedbands {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedindividual_artists {
		edges = append(edges, label.EdgeIndividualArtists)
	}
	if m.clearedbands {
		edges = append(edges, label.EdgeBands)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabelMutation) EdgeCleared(name string) bool {
	switch name {
	case label.EdgeIndividualArtists:
		return m.clearedindividual_artists
	case label.EdgeBands:
		return m.clearedbands
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Label unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabelMutation) ResetEdge(name string) error {
	switch name {
	case label.EdgeIndividualArtists:
		m.ResetIndividualArtists()
		return nil
	case label.EdgeBands:
		m.ResetBands()
		return nil
	}
	return fmt.Errorf("unknown Label edge %s", name)
}
